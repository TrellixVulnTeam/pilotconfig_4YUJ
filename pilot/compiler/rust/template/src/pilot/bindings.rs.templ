/*
 THIS FILE IS AUTOGENERATED. DO NOT EDIT
*/

{{#each memmodules}}
{{device.spec.decl.rust.decl}}{{/each}}

#[repr(C)]
pub struct plc_dev_t {
{{#each memmodules}}  pub m{{device.slot}}: {{device.spec.decl.rust.name}},
{{/each}}
}


pub trait PilotAccess {
    const FIELD_NUM: u16;
    const VARIABLES: &'static [VariableInfo];

    fn plc_varnumber_to_variable(&self, number: u16) -> Option<&dyn pilot_types::var::MemVar>;
}

impl<T: Default + TypeName> PilotAccess for pilot_types::var::Var<T>
where
    pilot_types::var::Var<T>: pilot_types::var::MemVar,
{
    const FIELD_NUM: u16 = 1;
    const VARIABLES: &'static [VariableInfo] = &[VariableInfo {
        name: "value",
        ty: T::TYPE_NAME,
        fields: &[],
        field_number_offset: 0,
    }];

    fn plc_varnumber_to_variable(&self, number: u16) -> Option<&dyn pilot_types::var::MemVar> {
        match number {
            0 => Some(self),
            _ => None,
        }
    }
}

pub trait PilotBindings {
    type BindType;

    fn set_from_pilot_bindings(&self, plc_mem: &Self::BindType);

    fn write_to_pilot_bindings(&self, plc_mem: &mut Self::BindType);
}

#[derive(Debug)]
#[repr(C)]
pub struct VariableInfo {
    pub name: &'static str,
    pub ty: &'static str,
    pub fields: &'static [VariableInfo], // for compound types
    pub field_number_offset: u16,        // field number adjustments for compound fields
}

pub trait TypeName {
    const TYPE_NAME: &'static str;
}

impl TypeName for u32 {
    const TYPE_NAME: &'static str = "u32";
}
impl TypeName for i32 {
    const TYPE_NAME: &'static str = "i32";
}
impl TypeName for u16 {
    const TYPE_NAME: &'static str = "u16";
}
impl TypeName for i16 {
    const TYPE_NAME: &'static str = "i16";
}
impl TypeName for u8 {
    const TYPE_NAME: &'static str = "u8";
}
impl TypeName for i8 {
    const TYPE_NAME: &'static str = "i8";
}
impl TypeName for bool {
    const TYPE_NAME: &'static str = "bool";
}
